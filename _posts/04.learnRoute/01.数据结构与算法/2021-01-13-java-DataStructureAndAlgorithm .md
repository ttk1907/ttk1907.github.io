---
layout: post
title:  "数据结构与算法01"
date:   2021-01-13
categories: study
tags: study
---

* content
{:toc}

1. 线性结构与非线性结构
2. 稀疏数组
3. 队列和数组模拟环形队列
4. 链表




# 一、线性结构和非线性结构

1. 线性结构
    1. 线性结构作为最常用的数据结构，其特点是数据元素之间存在一对一的线性关系
    2. 线性结构有两种不同的存储结构，即顺序存储结构(数组)和链式存储结构(链表)。顺序存储的线性表称为顺序表，顺序表中的存储元素是连续的
    3. 链式存储的线性表称为链表，链表中的存储元素不一定是连续的，元素节点中存放数据元素以及相邻元素的地址信息
    4. 线性结构常见的有：数组、队列、链表和栈，后面我们会详细讲解.
2. 非线性结构
    1. 非线性结构包括：二维数组，多维数组，广义表，树结构，图结构

# 二、稀疏数组

1. 使用场景:
编写的五子棋程序中， 有存盘退出和续上盘的功能。
![五子棋图片](/assets/01.java提升计划/01.数据结构与算法/01/五子棋.jpg)

2. 分析问题:
因为该二维数组的很多值是默认值 0, 因此记录了很多没有意义的数据-->稀疏数组。

3. 基本介绍:
当一个数组中大部分元素为０，或者为同一个值的数组时，可以使用稀疏数组来保存该数组。稀疏数组的处理方法是:
    1. 记录数组一共有几行几列，有多少个不同的值
    2. 把具有不同值的元素的行列及值记录在一个小规模的数组中，从而缩小程序的规模
    ![稀疏数组](/assets/01.java提升计划/01.数据结构与算法/01/稀疏数组.jpg)

4. 应用实例
    1. 使用稀疏数组，来保留类似前面的二维数组(棋盘、地图等等)
    2. 把稀疏数组存盘，并且可以从新恢复原来的二维数组数
    3. 整体思路分析
    ![稀疏数组思路](/assets/01.java提升计划/01.数据结构与算法/01/稀疏数组思路.jpg)

# 三、队列

1. 使用场景:
银行排队叫号场景

2. 队列介绍
    1. 队列是一个有序列表，可以用数组或是链表来实现。
    2. 遵循先入先出的原则。即：先存入队列的数据，要先取出。后存入的要后取出

3. 数组模拟环形队列:
对前面的数组模拟队列的优化，充分利用数组. 因此将数组看做是一个环形的。(通过取模的方式来实现即可)
    1. front(首指针)变量的含义：front就指向队列的第一个元素，也就是说arr[front]就是队列的第一个元素，front的初始值是0
    2. rear(尾指针)：变量的含义：rear指向队列的最后一个元素的后一个位置，因为希望空出一个空间作为约定，rear的初始值=0
    3. 当队列满时，判断条件时(rear+1) % maxSize = front(实际上当队列最大长度为maxSize，其中放满元素时的容量为maxSize-1)
    4. 当队列为空的条件：rear==front
    5. 当我们这样分析，队列中有效的数据的个数(rear+maxSize-front)%maxSize

# 四、链表

## 1.单链表
1. 链表(Linked List)介绍:
链表是有序的列表，但是它在内存中是存储如下
    1. 链表是以节点的方式来存储,是链式存储
    2. 每个节点包含 data  域， next 域：指向下一个节点.
    3. 链表的各个节点不一定是连续存储.
    4. 链表分带头节点的链表和没有头节点的链表，根据实际的需求来确定
    ![链表介绍](/assets/01.java提升计划/01.数据结构与算法/01/链表介绍.jpg)

2. 单链表的应用实例
    1. 添加：
        1. 先创建一个head节点，作用就是表示单链表的头
        2. 后面我们每添加一个节点，就直接加入到链表的最后
    2. 修改：
        1. 先找到这个节点，修改其对应的属性
    3. 删除：
        1. 我们先找到需要删除的这个节点的前一个key
        2. temp.next = temp.next.next
        3. 被删除的节点，将不会有其他引用指向，会被垃圾回收机制回收

3. 单链表面试题
    1. 查找单链表的倒数第k个节点，思路：
        1. 将k和链表的头节点作为参数
        2. 先找出有多少个有效节点，比如有n个节点
        3. 找出第(n-k+1)个元素就是目标元素
    2. 单链表的反转,思路:
        1. 创建一个新的节点
        2. 依次将原链表的节点从头插入这个新节点的后面
        3. 然后将原链表的head节点的next指向新建节点的next
    3. 从尾到头打印单链表，思路：
        1. 先依次压栈，后依次出栈

## 2.双向链表
1. 管理单向链表的缺点分析:
    1. 单向链表,查找的方向只能是一个方向,而双向链表可以向前或者向后查找。
    2. 单向链表不能自我删除,需要靠辅助节点,而双向链表则可以自我删除,所以前面我们单链表删除时节点,总是找到temp,temp是待删除节点的前一个节点(认真体会).
    3. 添加和删除和单向链表类似，只不过是多了一个指向前一个节点的per指针，考虑进去便是

## 3. 约瑟夫环问题
1. Josephu(约瑟夫、 约瑟夫环)问题：Josephu 问题为： 设编号为 1,2,… n的 **n** 个人围坐一圈,约定编号为 **k（1<=k<=n）**的人从 1 开始报数,数到 **m** 的那个人出列,它的下一位又从 1 开始报数,数到 m 的那个人又出列,依次类推,直到所有人出列为止,由此产生一个出队编号的序列。

2. 思路： 用一个不带头结点的循环链表来处理 Josephu 问题： 先构成一个有 n 个结点的单循环链表,然后由 k 结点起从 1 开始计数,计到 m 时,对应结点从链表中删除,然后再从被删除结点的下一个结点又从 1 开始计数,直到最后一个结点从链表中删除算法结束

3. 单向环形链表介绍
就是最后一个节点的next指向第一个节点,整成一个圈

# 五、栈