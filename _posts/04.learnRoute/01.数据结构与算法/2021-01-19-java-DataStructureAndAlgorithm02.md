---
layout: post
title:  "数据结构与算法02-基础算法"
date:   2021-01-19
categories: study
tags: DataStructureAndAlgorithm
---

* content
{:toc}

1. 递归
2. 排序算法
3. 查找算法




# 一、递归
1. 递归应用场景
    1. 迷宫问题，回溯问题

2. 递归的概念
简单的说: **递归就是方法自己调用自己**,每次调用时**传入不同的变量**，递归有助于编程者解决复杂的问题,同时可以让代码变得简洁

3. 递归调用机制
    1. 使用图解方式说明了递归的调用机制
    ![递归图解](/assets/01.java提升计划/01.数据结构与算法/02/递归图解.jpg)

4. 递归能解决什么样的问题
    1. 各种数学问题如: 8 皇后问题,汉诺塔,阶乘问题,迷宫问题,球和篮子的问题(google 编程大赛)
    2. 各种算法中也会使用到递归,比如快排,归并排序,二分查找,分治算法等.
    3. 将用栈解决的问题-->递归代码比较简洁

5. 递归需要遵守的重要规则
    1. 执行一个方法时,就创建一个新的受保护的独立空间(栈空间)
    2. 方法的局部变量是独立的,不会相互影响,比如 n 变量
    3. 如果方法中使用的是引用类型变量(比如数组),就会共享该引用类型的数据.
    4. 递归必须向退出递归的条件逼近,否则就是无限递归,出现 StackOverflowError)
    5. 当一个方法执行完毕,或者遇到 return,就会返回,遵守谁调用,就将结果返回给谁,同时当方法执行完毕或者返回时,该方法也就执行完毕

# 二、排序算法
## 1.冒泡排序
1. 冒泡排序（Bubble Sorting）的基本思想是：通过对待排序序列从前向后（从下标较小的元素开始）,**依次比较相邻元素的值，若发现逆序则交换**，使值较大的元素逐渐从前移向后部，就象水底下的气泡一样逐渐向上冒。
2. 优化：因为排序的过程中，各元素不断接近自己的位置，**如果一趟比较下来没有进行过交换，就说明序列有序**，因此要在排序过程中设置一个标志 flag 判断元素是否进行过交换。从而减少不必要的比较。

## 2.选择排序
1. 选择排序（select sorting）也是一种简单的排序方法。它的基本思想是：
    1. 第一次从 arr[0] ~ arr[n-1]中选取最小值，与 arr[0]交换
    2. 第二次从 arr[1] ~ arr[n-1]中选取最小值，与 arr[1]交换
    3. 第三次从 arr[2] ~ arr[n-1]中选取最小值，与 arr[2]交换
    4. 第 i 次从 arr[i-1] ~ arr[n-1]中选取最小值，与 arr[i-1]交换
    5. 第 n-1 次从 arr[n-2] ~ arr[n-1]中选取最小值，与 arr[n-2]交换
    6. 总共通过 n-1 次，得到一个按排序码从小到大排列的有序序列。
2. 思路分析图
![选择排序思路](/assets/01.java提升计划/01.数据结构与算法/02/选择排序图解.jpg)

## 3.插入排序
1. 插入排序法思想:插入排序（Insertion Sorting）的基本思想是： 把 n 个待排序的元素看成为一个有序表和一个无序表，开始时有序表中只包含一个元素，无序表中包含有 n-1 个元素，排序过程中每次从无序表中取出第一个元素， 把它的排序码依次与有序表元素的排序码进行比较，将它插入到有序表中的适当位置，使之成为新的有序表。
2. 思路分析图
![插入排序思路](/assets/01.java提升计划/01.数据结构与算法/02/插入排序图解.jpg)

## 4.希尔排序
1. 希尔排序法基本思想 : 希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序； 随着增量逐渐减少，每组包含的关键词越来越多，当增量减至 1 时，整个文件恰被分成一组，算法便终止
2. 思路分析图
![希尔排序思路](/assets/01.java提升计划/01.数据结构与算法/02/希尔排序图解.jpg)
3. 希尔排序时，对有序序列在插入时采用交换法, 并测试排序速度(较慢,相当于冒泡)
4. 希尔排序时，对有序序列在插入时采用移动法, 并测试排序速度(很快,相当于普通插入排序)

## 5.快速排序
1. 快速排序法介绍:快速排序（Quicksort） 是对冒泡排序的一种改进。 
2. 基本思想是： 通过一趟排序将要排序的数据分割成独立的两
部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列
3. 思路分析图
![快速排序思路](/assets/01.java提升计划/01.数据结构与算法/02/快速排序图解.jpg)

## 6.归并排序
1. 基本思想是：将数组拆成每个部分只有一个数字的时候,再开始合并排序,最后得出有序数组
2. 思路分析图01
![归并排序思路01](/assets/01.java提升计划/01.数据结构与算法/02/归并排序图解01.jpg)
3. 思路分析图02 : 我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将[4,5,7,8]和[1,2,3,6]两个已经有序的子序列，合并为最终序列[1,2,3,4,5,6,7,8]，来看下实现步骤
![归并排序思路02](/assets/01.java提升计划/01.数据结构与算法/02/归并排序图解02.jpg)

## 7.基数排序(桶排序)
1. 基数排序(桶排序)介绍:
    1. 基数排序（radix sort）属于"分配式排序"（distribution sort），又称"桶子法"（bucket sort）或 bin sort，顾名思义，它是通过键值的各个位的值，将要排序的元素分配至某些"桶"中，达到排序的作用
    2. 基数排序法是属于稳定性的排序，基数排序法的是效率高的稳定性排序法
    3. 基数排序(Radix Sort)是桶排序的扩展
    4. 基数排序是 1887 年赫尔曼·何乐礼发明的。它是这样实现的：将整数按位数切割成不同的数字，然后按每个位数分别比较。
2. 基数排序基本思想
    1. 将所有待比较数值统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。
3. 思路分析图
![基数排序思路01](/assets/01.java提升计划/01.数据结构与算法/02/基数排序图解01.jpg)
![基数排序思路02](/assets/01.java提升计划/01.数据结构与算法/02/基数排序图解02.jpg)
![基数排序思路03](/assets/01.java提升计划/01.数据结构与算法/02/基数排序图解03.jpg)

## 8.堆排序
1. 堆排序的基本思想是：
    1. 将待排序序列构造成一个大顶堆
    2. 此时， 整个序列的最大值就是堆顶的根节点。
    3. 将其与末尾元素进行交换， 此时末尾就为最大值。
    4. 然后将剩余 n-1 个元素重新构造成一个堆，这样会得到 n 个元素的次小值。 如此反复执行， 便能得到一个有序序列了
2. 图解
要求： 给你一个数组{4,6,8,5,9},要求使用堆排序法，将数组升序排序。
    1. **步骤一 构造初始堆。将给定无序序列构造成一个大顶堆（一般升序采用大顶堆，降序采用小顶堆)。原始的数组 [4, 6, 8, 5, 9]**
        1. 假设给定无序序列结构如下
        ![堆排序01](/assets/01.java提升计划/01.数据结构与算法/02/堆排序01.jpg)
        2. 此时我们从最后一个非叶子结点开始（叶结点自然不用调整，第一个非叶子结点arr.length/2-1=5/2-1=1，也就是下面的**6**结点），从左至右，从下至上进行调整
        ![堆排序02](/assets/01.java提升计划/01.数据结构与算法/02/堆排序02.jpg)
        3. 找到第二个非叶节点 4，由于[4,9,8]中 9 元素最大，4 和 9 交换。
        ![堆排序03](/assets/01.java提升计划/01.数据结构与算法/02/堆排序03.jpg)
        4. 这时，交换导致了子根[4,5,6]结构混乱，继续调整，[4,5,6]中 6 最大，交换 4 和 6。
        ![堆排序04](/assets/01.java提升计划/01.数据结构与算法/02/堆排序04.jpg)
        5. 此时，我们就将一个无序序列构造成了一个大顶堆。
    2. **步骤二 将堆顶元素与末尾元素进行交换，使末尾元素最大。然后继续调整堆，再将堆顶元素与末尾元素交换，得到第二大元素。如此反复进行交换、重建、交换。**
        1. 将堆顶元素 9 和末尾元素 4 进行交换
        ![堆排序05](/assets/01.java提升计划/01.数据结构与算法/02/堆排序05.jpg)
        2. 重新调整结构，使其继续满足堆定义
        ![堆排序06](/assets/01.java提升计划/01.数据结构与算法/02/堆排序06.jpg)
        3. 再将堆顶元素 8 与末尾元素 5 进行交换，得到第二大元素 8.
        ![堆排序07](/assets/01.java提升计划/01.数据结构与算法/02/堆排序07.jpg)
        4. 后续过程，继续进行调整，交换，如此反复进行，最终使得整个序列有序
        ![堆排序08](/assets/01.java提升计划/01.数据结构与算法/02/堆排序08.jpg)

## 9.常用排序算法总结和对比
1. 常用排序算法时间复杂度对比表
![常用排序算法时间复杂度对比表](/assets/01.java提升计划/01.数据结构与算法/02/常用排序算法时间复杂度对比表.jpg)

# 三、查找算法
查找算法介绍,在java中,我们常用的查找有四种:

## 1.顺序(线性)查找
1. 有一个数列： {1,8, 10, 89, 1000, 1234},判断数列中是否包含此名称
2. 顺序查找要求: 遍历数组,如果找到了,就提示找到,并给出下标值。

## 2.二分查找/折半查找
1. 首先确定该数组的中间下标 mid = (left+right)/2
2. 然后让需要查找的数findVal和arr[mid]比较
    1. findVal > arr[mid],说明你要查找的数在mid的右边,因此需要递归的向右查找
    2. findVal < arr[mid],说明你要查找的数在mid的左边,因此需要递归的向左查找
    3. findVal == arr[mid],说明找到,就返回
3. 注意事项
    1. 当找到findVal或者left>right就需要退出

## 3.插值查找
1. 插值查找原理介绍:插值查找算法类似于二分查找,不同的是插值查找每次从自适应 mid 处开始查找。
2. 将折半查找中的求 mid 索引的公式 , low 表示左边索引 left, high 表示右边索引 right,key 就是前面我们讲的 findVal
3. 求mid的公式
```java
//插值索引
int mid = low + (high - low) * (key - arr[low]) / (arr[high] - arr[low]);
```

4. 注意事项
    1. 对于数据量较大,关键字分布比较均匀的查找表来说,采用插值查找,速度较快.
    2. 关键字分布不均匀的情况下,该方法不一定比折半查找要好

## 4.斐波那契查找
1. 原理:斐波那契查找原理与前两种相似,仅仅改变了中间结点（mid） 的位置,mid 不再是中间或插值得到,而是位于黄金分割点附近,即 mid=low+F(k-1)-1（F 代表斐波那契数列）,如下图所示
2. 对 **F(k-1)-1** 的理解：
    1. 由斐波那契数列 F[k]=F[k-1]+F[k-2] 的性质， 可以得到 （F[k]-1） =（F[k-1]-1） +（F[k-2]-1） +1 。 该式说明：只要顺序表的长度为 F[k]-1， 则可以将该表分成长度为 F[k-1]-1 和 F[k-2]-1 的两段， 即如上图所示。 从而中间位置为mid=low+F(k-1)-1
3. 类似的,每一子段也可以用相同的方式分割
4. 但顺序表长度 n 不一定刚好等于 F[k]-1，所以需要将原来的顺序表长度 n 增加至 F[k]-1。 这里的 k 值只要能使得 F[k]-1 恰好大于或等于 n 即可， 由以下代码得到,顺序表长度增加后， 新增的位置（从 n+1 到 F[k]-1 位置） ，都赋为 n 位置的值即可。
```java
//fib(k)为获取斐波那契数列中对应k位置的值
while(n>fib(k)-1)
    k++;
```