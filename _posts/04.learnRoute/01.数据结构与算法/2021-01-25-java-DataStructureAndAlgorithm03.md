---
layout: post
title:  "数据结构与算法03-高级数据结构"
date:   2021-01-25
categories: study
tags: DataStructureAndAlgorithm
---

* content
{:toc}

1. 哈希表
2. 树
3. 图




# 一、哈希表
1. 哈希表的基本介绍:散列表（Hash table,也叫哈希表）,是根据关键码值(Key value)而直接进行访问的数据结构。也就是说,它通过把关键码值映射到表中一个位置来访问记录,以加快查找的速度。这个映射函数叫做散列函数, 叫做散列表。
![哈希表数据结构](/assets/01.java提升计划/01.数据结构与算法/03/哈希表数据结构.jpg)

2. google公司的一个上机题:
有一个公司,当有新的员工来报道时,要求将该员工的信息加入id,性别,年龄,名字,住址..),当输入该员工的 id 时,要求查找到该员工的 所有信息
要求:
    1. 不使用数据库,,速度越快越好=>哈希表(散列)
    2. 添加时, 保证按照 id 从低到高插入 (课后思考： 如果 id 不是从低到高插入, 但要求各条链表仍是从低到高, 怎么解决?)
    3. 使用链表来实现哈希表, 该链表不带表头(即:链表的第一个结点就存放雇员信息)
    4. 思路分析并画出示意图

3. 实现图
![哈希表实现图](/assets/01.java提升计划/01.数据结构与算法/03/哈希表实现图.jpg)

# 二、树结构的基础部分

## 1.二叉树
1. 树的常用术语
    1. 节点、根节点、父节点、子节点、叶子节点 (没有子节点的节点)、节点的权(节点值)、路径(从 root 节点找到该节点的路线)、层、树的高度(最大层数)、森林 :多颗子树构成森林
    ![树的常用术语](/assets/01.java提升计划/01.数据结构与算法/03/树的常用术语.jpg)

2. 二叉树的概念
    1. 如果该二叉树的所有叶子节点都在最后一层,并且结点总数=**2^n-1**,n 为层数,则我们称为满二叉树
    2. 如果该二叉树的所有叶子节点都在最后一层或者倒数第二层,而且最后一层的叶子节点在左边连续,倒数第二层的叶子节点在右边连续,我们称为完全二叉树

3. 二叉树的遍历
    1. 前序遍历: 先输出父节点,再遍历左子树和右子树
    2. 中序遍历: 先遍历左子树,再输出父节点,再遍历右子树
    3. 后序遍历: 先遍历左子树,再遍历右子树,最后输出父节点
    ![树的遍历方式](/assets/01.java提升计划/01.数据结构与算法/03/树的遍历方式.jpg)

## 2.顺序存储二叉树
1. 顺序存储二叉树的概念 : 从数据存储来看,数组存储方式和树的存储方式可以相互转换,即数组可以转换成树,树也可以转换成数组  
![顺序存储二叉树](/assets/01.java提升计划/01.数据结构与算法/03/顺序存储二叉树.jpg)

2. 顺序存储二叉树的特点:
    1. 顺序二叉树通常只考虑完全二叉树
    2. 第 n 个元素的左子节点为 2 \* n + 1
    3. 第 n 个元素的右子节点为 2 \* n + 2
    4. 第 n 个元素的父节点为 (n-1) / 2
    5. 表示二叉树中的第几个元素(按 0 开始编号如图所示)

## 3.线索化二叉树
1. 线索二叉树基本介绍  
    1. n 个结点的二叉链表中含有 n+1 【公式 2n-(n-1)=n+1】个空指针域。 利用二叉链表中的空指针域,存放指向该结点在某种遍历次序下的前驱和后继结点的指针（这种附加的指针称为"线索"）
    2. 这种加上了线索的二叉链表称为线索链表,相应的二叉树称为线索二叉树(Threaded BinaryTree)。 根据线索性质的不同,线索二叉树可分为前序线索二叉树、中序线索二叉树和后序线索二叉树三种
    3. 一个结点的前一个结点,称为前驱结点
    4. 一个结点的后一个结点,称为后继结点

# 三、树结构实际应用

## 1.堆排序
[堆排序](https://ttk1907.github.io/2021/01/19/java-DataStructureAndAlgorithm02/#8%E5%A0%86%E6%8E%92%E5%BA%8F)

## 2.赫夫曼树
1. 基本介绍
    1. 给定 n 个权值作为 n 个叶子结点,构造一棵二叉树,若该树的带权路径长度(wpl)达到最小,称这样的二叉树为最优二叉树,也称为哈夫曼树(Huffman Tree),还有的书翻译为霍夫曼树。
    2. 赫夫曼树是带权路径长度最短的树,权值较大的结点离根较近

2. 赫夫曼树几个重要概念和举例说明
    1. **路径和路径长度**：在一棵树中,从一个结点往下可以达到的孩子或孙子结点之间的通路,称为路径。通路中分支的数目称为路径长度。若规定根结点的层数为 1,则从根结点到第 L 层结点的路径长度为 L-1
    2. **结点的权及带权路径长度**：若将树中结点赋给一个有着某种含义的数值,则这个数值称为该结点的权。结点的带权路径长度为：从根结点到该结点之间的路径长度与该结点的权的乘积
    3. **树的带权路径长度**：树的带权路径长度规定为所有叶子结点的带权路径长度之和,记为**WPL(weighted path length)**,权值越大的结点离根结点越近的二叉树才是最优二叉树。
    4. WPL 最小的就是赫夫曼树   
    ![赫夫曼树图解](/assets/01.java提升计划/01.数据结构与算法/03/赫夫曼树图解.jpg)

3. 赫夫曼树创建思路图解
给你一个数列 {13, 7, 8, 3, 29, 6, 1}， 要求转成一颗赫夫曼树.
构成赫夫曼树的步骤：
    1. 从小到大进行排序,将每一个数据,每个数据都是一个节点,每个节点可以看成是一颗最简单的二叉树
    2. 取出根节点权值最小的两颗二叉树
    3. 组成一颗新的二叉树,该新的二叉树的根节点的权值是前面两颗二叉树根节点权值的和
    4. 再将这颗新的二叉树,以根节点的权值大小再次排序,不断重复1-2-3-4 的步骤,直到数列中,所有的数据都被处理,就得到一颗赫夫曼树
    5. 图解:  
    ![构建赫夫曼树](/assets/01.java提升计划/01.数据结构与算法/03/构建赫夫曼树.jpg)

## 3.赫夫曼编码
1. 基本介绍
    1. 赫夫曼编码也翻译为哈夫曼编码(Huffman Coding),又称霍夫曼编码,是一种编码方式,属于一种程序算法
    2. 赫夫曼编码是赫哈夫曼树在电讯通信中的经典的应用之一。
    3. 赫夫曼编码广泛地用于数据文件压缩。其压缩率通常在 20%～90%之间
    4. 赫夫曼码是可变字长编码(VLC)的一种。Huffman于 1952年提出一种编码方法,称之为最佳编码
2. 原理剖析
    1. 传输的字符串 : "i like like like java do you like a java"
    2. d:1 y:1 u:1 j:2 v:2 o:2 l:4 k:4 e:4 i:5 a:5 空格:9 //各个字符对应的个数
    3. 按照上面字符出现的次数构建一颗赫夫曼树,次数作为权值   
    ![赫夫曼编码树](/assets/01.java提升计划/01.数据结构与算法/03/赫夫曼编码树.jpg)
    4. 根据赫夫曼树,给各个字符,规定编码(前缀编码),向左的路径为**0**,向右的路径为**1**,编码如下:
    5. o:1000 u:10010 d:100110 y:100111 i:101 a:110 k:1110 e:1111 j:0000 v:0001 l:001 空格:01
    6. 按照传输的字符串的顺序编写赫夫曼编码:"10101001..."

## 4.二叉排序树
1. 基本介绍：BST(Binary Sort(Search) Tree),对于二叉排序树的任何一个非叶子节点,要求左子节点的值比当
前节点的值小,右子节点的值比当前节点的值大。(特别说明： 如果有相同的值,可以将该节点放在左子节点或右子节点)
2. 比如针对数据 (7, 3, 10, 12, 5, 1, 9) ,对应的二叉排序树为：   
![二叉排序树](/assets/01.java提升计划/01.数据结构与算法/03/二叉排序树.jpg)
3. 二叉排序树创建和遍历:一个数组创建成对应的二叉排序树, 并使用中序遍历二叉排序树,比如: 数组为 Array(7, 3, 10, 12, 5, 1, 9) ,创建成对应的二叉排序树为 :   
![二叉排序树创建和遍历](/assets/01.java提升计划/01.数据结构与算法/03/二叉排序树创建和遍历.jpg)
4. 二叉排序树的删除:二叉排序树的删除情况比较复杂,有下面三种情况需要考虑  
![二叉树删除](/assets/01.java提升计划/01.数据结构与算法/03/二叉树删除.jpg)
    1. 删除叶子节点 (比如:2,5,9,12)
        1. 需求先去找到要删除的结点 targetNode
        2. 找到 targetNode 的 父结点 parent
        3. 确定 targetNode 是 parent 的左子结点 还是右子结点
        4. 根据前面的情况来对应删除,左子结点 parent.left = null,右子结点 parent.right = null
    2. 删除只有一颗子树的节点 (比如：1)
        1. 需求先去找到要删除的结点 targetNode
        2. 找到 targetNode 的 父结点 parent
        3. 确定 targetNode 的子结点是左子结点还是右子结点
        4. targetNode 是 parent 的左子结点还是右子结点
        5. 如果 targetNode 有左子结点
            1. 如果 targetNode 是 parent 的左子结点,parent.left = targetNode.left;
            2. 如果 targetNode 是 parent 的右子结点,parent.right = targetNode.left;
        6. 如果 targetNode 有右子结点
            1. 如果 targetNode 是 parent 的左子结点,parent.left = targetNode.right;
            2. 如果 targetNode 是 parent 的右子结点,parent.right = targetNode.right;
    3. 删除有两颗子树的节点. (比如：7,3,10 )
        1. 需求先去找到要删除的结点 targetNode
        2. 找到 targetNode 的 父结点 parent
        3. 从 targetNode 的右子树找到最小的结点
        4. 用一个临时变量， 将 最小结点的值保存 temp = 11
        5. 删除该最小结点
        6. targetNode.value = temp

## 5.平衡二叉树(AVL树)
1. 看一个案例(说明二叉排序树可能的问题),给你一个数列{1,2,3,4,5,6}， 要求创建一颗二叉排序树(BST),并分析问题所在
    1. 左子树全部为空,从形式上看,更像一个单链表.
    2. 插入速度没有影响
    3. 查询速度明显降低(因为需要依次比较),不能发挥BST的优势,因为每次还需要比较左子树,其查询速度比单链表还慢
    4. 解决方案-平衡二叉树(AVL)
2. 基本介绍
    1. 平衡二叉树也叫平衡**二叉搜索树**（Self-balancing binary search tree） 又被称为 AVL 树,可以保证查询效率较高。
    2. 具有以下特点：它是**一棵空树**或**它的左右两个子树的高度差的绝对值不超过 1**,并且**左右两个子树都是一棵平衡二叉树**。平衡二叉树的常用实现方法有红黑树、 AVL、 替罪羊树、 Treap、 伸展树等。
    3. 举例说明,看看下面哪些 AVL 树,为什么?   
    ![平衡二叉树](/assets/01.java提升计划/01.数据结构与算法/03/平衡二叉树.jpg)
3. 应用案例-单旋转(左旋转)
    1. 要求: 给你一个数列,创建出对应的平衡二叉树,数列{4,3,6,5,7,8}
    2. 思路分析(示意图)   
    ![左旋转](/assets/01.java提升计划/01.数据结构与算法/03/左旋转.jpg)  
    ```java
private void leftRotate() {
    //创建新的结点,以当前根结点的值
    Node newNode = new Node(value);
    //把新的结点的左子树设置成当前结点的左子树
    newNode.left = left;
    //把新的结点的右子树设置成带你过去结点的右子树的左子树
    newNode.right = right.left;
    //把当前结点的值替换成右子结点的值
    value = right.value;
    //把当前结点的右子树设置成当前结点右子树的右子树
    right = right.right;
    //把当前结点的左子树(左子结点)设置成新的结点
    left = newNode;
}
    ```

4. 应用案例-单旋转(右旋转)
    1. 要求:给你一个数列,创建出对应的平衡二叉树,数列{10,12,8,9,7,6}
    2. 思路分析(示意图)  
    ![右旋转](/assets/01.java提升计划/01.数据结构与算法/03/右旋转.jpg)   
    ```java
private void rightRotate() {
    Node newNode = new Node(value);
    newNode.right = right;
    newNode.left = left.right;
    value = left.value;
    left = left.left;
    right = newNode;
}
    ```

5. 应用案例-双旋转
    1. 前面的两个数列,进行单旋转(即一次旋转)就可以将非平衡二叉树转成平衡二叉树,但是在某些情况下,单旋转不能完成平衡二叉树的转换。比如数列
    2. int[] arr = { 10, 11, 7, 6, 8, 9 };运行原来的代码可以看到,并没有转成 AVL 树.
    3. int[] arr = {2,1,6,5,7,3};运行原来的代码可以看到,并没有转成 AVL 树
    4. 问题分析  
    ![双旋转](/assets/01.java提升计划/01.数据结构与算法/03/双旋转.jpg)   
    5. 解决思路分析
        1. 当符号右旋转的条件时
        2. 如果它的左子树的右子树高度大于它的左子树的高度
        3. 先对当前这个结点的左节点进行左旋转
        4. 在对当前结点进行右旋转的操作即可



# 四、多路查找树

## 1.二叉树与B树
1. 二叉树的问题分析:二叉树的操作效率较高,但是也存在问题,请看下面的二叉树  
![多路查找第一图](/assets/01.java提升计划/01.数据结构与算法/03/多路查找第一图.jpg)
    1. 二叉树需要加载到内存的,如果二叉树的节点少,没有什么问题,但是如果二叉树的节点很多(比如 1 亿,就存在如下问题:
    2. 问题 1：在构建二叉树时,需要多次进行 i/o 操作(海量数据存在数据库或文件中),节点海量,构建二叉树时,速度有影响
    3. 问题 2：节点海量,也会造成二叉树的高度很大,会降低操作速度.
2. 多叉树
    1. 在二叉树中,每个节点有数据项,最多有两个子节点。如果允许每个节点可以有更多的数据项和更多的子节点,就是多叉树（multiway tree）
    2. 后面我们讲解的 2-3 树,2-3-4 树就是多叉树,多叉树通过重新组织节点,减少树的高度,能对二叉树进行优化。
    3. 举例说明(下面 2-3 树就是一颗多叉树)   
    ![2-3树](/assets/01.java提升计划/01.数据结构与算法/03/2-3树.jpg)
3. B树的基本介绍 : B树通过重新组织节点,降低树的高度,并且减少 i/o 读写次数来提升效率。   
    ![B树](/assets/01.java提升计划/01.数据结构与算法/03/B树.jpg)
    1. 如图 B 树通过重新组织节点,降低了树的高度.
    2. 文件系统及数据库系统的设计者利用了磁盘预读原理,将一个节点的大小设为等于一个页(页得大小通常为 4k),这样每个节点只需要一次 I/O 就可以完全载入
    3. 将树的度 M 设置为 1024,在 600 亿个元素中最多只需要 4 次 I/O 操作就可以读取到想要的元素, B树(B+)广泛应用于文件存储系统以及数据库系统中

## 2.2-3树
1. 2-3 树是最简单的 B 树结构, 具有如下特点:
    1. 2-3 树的所有叶子节点都在同一层.(只要是 B 树都满足这个条件)
    2. 有两个子节点的节点叫二节点,二节点要么没有子节点,要么有两个子节点
    3. 有三个子节点的节点叫三节点,三节点要么没有子节点,要么有三个子节点.
    4. 2-3 树是由二节点和三节点构成的树。
2. 2-3 树应用案例:将数列{16, 24, 12, 32, 14, 26, 34, 10, 8, 28, 38, 20} 构建成 2-3 树,并保证数据插入的大小顺序。 (演示一下构建 2-3
树的过程)  
![构建2-3树](/assets/01.java提升计划/01.数据结构与算法/03/构建2-3树.jpg)
    1. 2-3 树的所有叶子节点都在同一层.(只要是 B 树都满足这个条件)
    2. 有两个子节点的节点叫二节点,二节点要么没有子节点,要么有两个子节点.
    3. 有三个子节点的节点叫三节点,三节点要么没有子节点,要么有三个子节点
    4. 当按照规则插入一个数到某个节点时,不能满足上面三个要求,就需要拆,先向上拆,如果上层满,则拆本层,拆后仍然需要满足上面 3 个条件。
    5. 对于三节点的子树的值大小仍然遵守(BST 二叉排序树)的规则
3. 其它说明:除了 2-3 树,还有2-3-4树等,概念和 2-3 树类似,也是一种 B 树。 如图   
![2-3-4树](/assets/01.java提升计划/01.数据结构与算法/03/2-3-4树.jpg)

## 3.B树、B+树和B\*树
1. B树的介绍 : B-tree 树即 B 树,B 即 Balanced,平衡的意思。有人把 B-tree 翻译成 B-树,容易让人产生误解。 会以为 B-树是一种树,而 B 树又是另一种树。实际上,B-tree 就是指的 B 树。
2. B 树的介绍 : 前面已经介绍了 2-3 树和 2-3-4 树,他们就是 B 树(英语： B-tree 也写成 B-树),这里我们再做一个说明,我们在学习 Mysql 时,经常听到说某种类型的索引是基于 B 树或者 B+树的,如图:   
![B数索引](/assets/01.java提升计划/01.数据结构与算法/03/B数索引.jpg)
对上图的说明:
    1. B 树的阶： 节点的最多子节点个数。 比如 2-3 树的阶是 3,2-3-4 树的阶是 4
    2. B-树的搜索,从根结点开始,对结点内的关键字（有序）序列进行二分查找,如果命中则结束,否则进入查询关键字所属范围的儿子结点;重复,直到所对应的儿子指针为空,或已经是叶子结点
    3. 关键字集合分布在整颗树中,即叶子节点和非叶子节点都存放数据.
    4. 搜索有可能在非叶子结点结束
    5. 其搜索性能等价于在关键字全集内做一次二分查找
3. B+树的介绍 : B+树是 B 树的变体,也是一种多路搜索树。  
![B+树](/assets/01.java提升计划/01.数据结构与算法/03/B+树.jpg)
对上图的说明:
    1. B+树的搜索与 B 树也基本相同,区别是B+树只有达到叶子结点才命中（B 树可以在非叶子结点命中）,其性能也等价于在关键字全集做一次二分查找
    2. 所有关键字都出现在叶子结点的链表中（即数据只能在叶子节点【也叫稠密索引】 ）,且链表中的关键字(数据)恰好是有序的
    3. 不可能在非叶子结点命中
    4. 非叶子结点相当于是叶子结点的索引（稀疏索引）,叶子结点相当于是存储（关键字）数据的数据层
    5. 更适合文件索引系统
    6. B 树和 B+树各有自己的应用场景,不能说 B+树完全比 B 树好,反之亦然.
4. B\*树的介绍 : B\*树是B+树的变体,在B+树的非根和非叶子结点再增加指向兄弟的指针  
![B星树](/assets/01.java提升计划/01.数据结构与算法/03/B星树.jpg)
B\*树的说明:
    1. B\*树定义了非叶子结点关键字个数至少为(2/3)\*M,即块的最低使用率为 2/3,而 B+树的块的最低使用率为的1/2。
    2. 从第 1 个特点我们可以看出,B\*树分配新结点的概率比 B+树要低,空间使用率更高

# 五、图

## 1.图的基础知识
## 2.图的深度优先遍历介绍
## 3.图的广度优先遍历 