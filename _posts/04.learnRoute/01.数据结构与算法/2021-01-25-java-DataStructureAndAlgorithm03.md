---
layout: post
title:  "数据结构与算法03-高级数据结构"
date:   2021-01-25
categories: study
tags: DataStructureAndAlgorithm
---

* content
{:toc}

1. 哈希表
2. 树
3. 图




# 一、哈希表
1. 哈希表的基本介绍:散列表（Hash table,也叫哈希表）,是根据关键码值(Key value)而直接进行访问的数据结构。也就是说,它通过把关键码值映射到表中一个位置来访问记录,以加快查找的速度。这个映射函数叫做散列函数, 叫做散列表。
![哈希表数据结构](/assets/01.java提升计划/01.数据结构与算法/03/哈希表数据结构.jpg)

2. google公司的一个上机题:
有一个公司,当有新的员工来报道时,要求将该员工的信息加入id,性别,年龄,名字,住址..),当输入该员工的 id 时,要求查找到该员工的 所有信息
要求:
    1. 不使用数据库,,速度越快越好=>哈希表(散列)
    2. 添加时, 保证按照 id 从低到高插入 (课后思考： 如果 id 不是从低到高插入, 但要求各条链表仍是从低到高, 怎么解决?)
    3. 使用链表来实现哈希表, 该链表不带表头(即:链表的第一个结点就存放雇员信息)
    4. 思路分析并画出示意图

3. 实现图
![哈希表实现图](/assets/01.java提升计划/01.数据结构与算法/03/哈希表实现图.jpg)

# 二、树结构的基础部分

## 1.二叉树
1. 树的常用术语
    1. 节点、根节点、父节点、子节点、叶子节点 (没有子节点的节点)、节点的权(节点值)、路径(从 root 节点找到该节点的路线)、层、树的高度(最大层数)、森林 :多颗子树构成森林
    ![树的常用术语](/assets/01.java提升计划/01.数据结构与算法/03/树的常用术语.jpg)

2. 二叉树的概念
    1. 如果该二叉树的所有叶子节点都在最后一层,并且结点总数=**2^n-1**,n 为层数,则我们称为满二叉树
    2. 如果该二叉树的所有叶子节点都在最后一层或者倒数第二层,而且最后一层的叶子节点在左边连续,倒数第二层的叶子节点在右边连续,我们称为完全二叉树

3. 二叉树的遍历
    1. 前序遍历: 先输出父节点,再遍历左子树和右子树
    2. 中序遍历: 先遍历左子树,再输出父节点,再遍历右子树
    3. 后序遍历: 先遍历左子树,再遍历右子树,最后输出父节点
    ![树的遍历方式](/assets/01.java提升计划/01.数据结构与算法/03/树的遍历方式.jpg)

## 2.顺序存储二叉树
1. 顺序存储二叉树的概念 : 从数据存储来看,数组存储方式和树的存储方式可以相互转换,即数组可以转换成树,树也可以转换成数组  
![顺序存储二叉树](/assets/01.java提升计划/01.数据结构与算法/03/顺序存储二叉树.jpg)

2. 顺序存储二叉树的特点:
    1. 顺序二叉树通常只考虑完全二叉树
    2. 第 n 个元素的左子节点为 2 \* n + 1
    3. 第 n 个元素的右子节点为 2 \* n + 2
    4. 第 n 个元素的父节点为 (n-1) / 2
    5. 表示二叉树中的第几个元素(按 0 开始编号如图所示)

## 3.线索化二叉树
1. 线索二叉树基本介绍  
    1. n 个结点的二叉链表中含有 n+1 【公式 2n-(n-1)=n+1】个空指针域。 利用二叉链表中的空指针域,存放指向该结点在某种遍历次序下的前驱和后继结点的指针（这种附加的指针称为"线索"）
    2. 这种加上了线索的二叉链表称为线索链表,相应的二叉树称为线索二叉树(Threaded BinaryTree)。 根据线索性质的不同,线索二叉树可分为前序线索二叉树、中序线索二叉树和后序线索二叉树三种
    3. 一个结点的前一个结点,称为前驱结点
    4. 一个结点的后一个结点,称为后继结点

# 三、树结构实际应用

## 1.堆排序
[堆排序](https://ttk1907.github.io/2021/01/19/java-DataStructureAndAlgorithm02/#8%E5%A0%86%E6%8E%92%E5%BA%8F)

## 2.赫夫曼树
1. 基本介绍
    1. 给定 n 个权值作为 n 个叶子结点,构造一棵二叉树,若该树的带权路径长度(wpl)达到最小,称这样的二叉树为最优二叉树,也称为哈夫曼树(Huffman Tree),还有的书翻译为霍夫曼树。
    2. 赫夫曼树是带权路径长度最短的树,权值较大的结点离根较近

2. 赫夫曼树几个重要概念和举例说明
    1. **路径和路径长度**：在一棵树中,从一个结点往下可以达到的孩子或孙子结点之间的通路,称为路径。通路中分支的数目称为路径长度。若规定根结点的层数为 1,则从根结点到第 L 层结点的路径长度为 L-1
    2. **结点的权及带权路径长度**：若将树中结点赋给一个有着某种含义的数值,则这个数值称为该结点的权。结点的带权路径长度为：从根结点到该结点之间的路径长度与该结点的权的乘积
    3. **树的带权路径长度**：树的带权路径长度规定为所有叶子结点的带权路径长度之和,记为**WPL(weighted path length)**,权值越大的结点离根结点越近的二叉树才是最优二叉树。
    4. WPL 最小的就是赫夫曼树   
    ![赫夫曼树图解](/assets/01.java提升计划/01.数据结构与算法/03/赫夫曼树图解.jpg)

3. 赫夫曼树创建思路图解
给你一个数列 {13, 7, 8, 3, 29, 6, 1}， 要求转成一颗赫夫曼树.
构成赫夫曼树的步骤：
    1. 从小到大进行排序,将每一个数据,每个数据都是一个节点,每个节点可以看成是一颗最简单的二叉树
    2. 取出根节点权值最小的两颗二叉树
    3. 组成一颗新的二叉树,该新的二叉树的根节点的权值是前面两颗二叉树根节点权值的和
    4. 再将这颗新的二叉树,以根节点的权值大小再次排序,不断重复1-2-3-4 的步骤,直到数列中,所有的数据都被处理,就得到一颗赫夫曼树
    5. 图解: 
    ![构建赫夫曼树](/assets/01.java提升计划/01.数据结构与算法/03/构建赫夫曼树.jpg)

## 3.赫夫曼编码
1. 基本介绍
    1. 赫夫曼编码也翻译为哈夫曼编码(Huffman Coding),又称霍夫曼编码,是一种编码方式,属于一种程序算法
    2. 赫夫曼编码是赫哈夫曼树在电讯通信中的经典的应用之一。
    3. 赫夫曼编码广泛地用于数据文件压缩。其压缩率通常在 20%～90%之间
    4. 赫夫曼码是可变字长编码(VLC)的一种。Huffman于 1952年提出一种编码方法,称之为最佳编码
2. 原理剖析
    1. 传输的字符串 : "i like like like java do you like a java"
    2. d:1 y:1 u:1 j:2 v:2 o:2 l:4 k:4 e:4 i:5 a:5 空格:9 //各个字符对应的个数
    3. 按照上面字符出现的次数构建一颗赫夫曼树,次数作为权值   
    ![赫夫曼编码树](/assets/01.java提升计划/01.数据结构与算法/03/赫夫曼编码树.jpg)
    4. 根据赫夫曼树,给各个字符,规定编码(前缀编码),向左的路径为**0**,向右的路径为**1**,编码如下:
    5. o:1000 u:10010 d:100110 y:100111 i:101 a:110 k:1110 e:1111 j:0000 v:0001 l:001 空格:01
    6. 按照传输的字符串的顺序编写赫夫曼编码:"10101001..."
    
## 4.二叉排序树
## 5.平衡二叉树(AVL 树)

# 四、多路查找树

## 1.二叉树与B树
## 2.2-3树
## 3.B树、B+树和B\*树

# 五、图

## 1.图的基础知识
## 2.图的深度优先遍历介绍
## 3.图的广度优先遍历