---
layout: post
title:  "数据结构与算法04-高级算法"
date:   2021-02-22
categories: study
tags: DataStructureAndAlgorithm
---

* content
{:toc}

1. 二分查找算法(非递归)
2. 分治算法
3. 动态规划
4. KMP算法
5. 贪心算法
6. 普利姆算法(Prim)
7. 克鲁斯卡尔算法(Kruskal)
8. 迪杰斯特拉算法(Dijkstra)
9. 弗洛伊德算法(Floyd)
10. 马踏棋盘算法




# 一、程序员常用10种算法

## 1.二分查找算法(非递归)
1. 二分查找算法(非递归)介绍
    1. 前面我们讲过了二分查找算法,是使用递归的方式,下面我们讲解二分查找算法的非递归方式
    2. 二分查找法只适用于从有序的数列中进行查找(比如数字和字母等),将数列排序后再进行查找
    3. 二分查找法的运行时间为对数时间 O(㏒₂n) ,即查找到需要的目标位置最多只需要 ㏒₂n 步, 假设从[0,99]的队列(100 个数, 即 n=100)中寻到目标数 30,则需要查找步数为 ㏒₂100 , 即最多需要查找 7 次( 2^6 < 100 < 2^7)   
2. 二分查找代码
```java
public static int binarySearch(int[] arr, int target) {
    int left = 0;
    int right = arr.length - 1;
    while(left <= right) { //说明继续查找 
        int mid = (left + right) / 2; 
        if(arr[mid] == target) {
            return mid;
        } else if ( arr[mid] > target) {
            right = mid - 1;//需要向左边查找
        } else {
            left = mid + 1; //需要向右边查找
        }
    }
    return -1;
}
```

## 2.分治算法
1. 分治算法介绍
    1. 分治法是一种很重要的算法。 字面上的解释是“分而治之" ，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题……直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。 这个技巧是很多高效算法的基础， 如排序算法(快速排序，归并排序)，傅立叶变换(快速傅立叶变换)……
    2. 分治算法可以求解的一些经典问题 : 二分搜索、大整数乘法、棋盘覆盖、合并排序、快速排序、线性时间选择、最接近点对问题、循环赛日程表、汉诺塔
2. 分治算法的基本步骤
分治法在每一层递归上都有三个步骤：
    1. 分解：将原问题分解为若干个规模较小，相互独立，与原问题形式相同的子问题
    2. 解决：若子问题规模较小而容易被解决则直接解，否则递归地解各个子问题
    3. 合并：将各个子问题的解合并为原问题的解。
3. 分治(Divide-and-Conquer(P))算法设计模式如下：  
![分值算法设计](/assets/01.java提升计划/01.数据结构与算法/04/分治算法设计.jpg)
4. 分治算法最佳实践-汉诺塔
    1. 汉诺塔的传说： 汉诺塔（又称河内塔）问题是源于印度一个古老传说的益智玩具。大梵天创造世界的时候做了三根金刚石柱子，在一根柱子上从下往上按照大小顺序摞着 64 片黄金圆盘。大梵天命令婆罗门把圆盘从下面开始按大小顺序重新摆放在另一根柱子上。 并且规定，在小圆盘上不能放大圆盘，在三根柱子之间一次只能移动一个圆盘。
    2. 思路分析:
        1. 如果是有一个盘， A->C
        2. 如果我们有 n >= 2 情况，我们总是可以看做是两个盘,最下边的盘和上面的盘
            1. 先把最上面的盘 A->B
            2. 把最下边的盘 A->C
            3. 把 B 塔的所有盘 从 B->C  
    3. 代码实现:
    ```java
public static void main(String[] args) {
        HanoiTower(5,'A','B','C');
}
private static void HanoiTower(int num, char a, char b, char c){
        if (num == 1){
            System.out.println(num+"号盘子: "+a+" -> "+c);
        } else {
            HanoiTower(num-1,a,c,b);//把多余的盘子由A->B
            System.out.println(num+"号盘子: "+a+" -> "+c);//把最大的由A->C
            HanoiTower(num-1,b,a,c);//把剩下的由B->C
        }
}
    ```

## 3.动态规划算法
1. 一道题目:有2,5,7三种硬币,现在要组成27元,问最少的硬币组合是多少枚
2. 动态规划四个步骤
    1. 确定状态：
        * 最后一步(最优策略中使用的最后一枚硬背ak)
        * 转化成子问题(最少的硬币拼出更小的面值27-ak)
    2. 转移方程:
        * f[x] = min{f[x-2]+1,f[x-5]+1,f[x-7]+1}
    3. 初始化和边界情况
        * f[0]=0,如果不能拼出Y,f[x]=-1
    4. 计算顺序
        * f[0],f[1],f[2],f[3]
3. 题解:
```java
public static int minCoin(int num) {
        int[] dp = new int[num + 1];
        dp[0] = 0;
        for (int i = 1; i < num + 1; i++) {
            dp[i] = Math.min(array(i - 2,dp), Math.min(array(i - 5,dp), array(i - 7,dp))) + 1;
        }
        return dp[num];
}
public static int array(int i,int[] dp) {
        if (i < 0) {
            return Integer.MAX_VALUE - 1;
        }
        return dp[i];
}
```

## 4.KMP算法
1. 应用场景-字符串匹配问题
    1. 有一个字符串 str1= "BBC ABCDAB ABCDABCDABDE"，和一个子串 str2="ABCDABD"
    2. 现在要判断 str1 是否含有 str2, 如果存在，就返回第一次出现的位置, 如果没有，则返回-1
2. 暴力匹配算法(jdk提供的indexOf方法用的就是暴力法)
    1. 如果当前字符匹配成功（即 str1[i] == str2[j]） ，则 i++，j++，继续匹配下一个字符
    2. 如果失配（即 str1[i]! = str2[j]） ，令 i = i - (j - 1)，j = 0。 相当于每次匹配失败时，i 回溯，j 被置为 0。
3. KMP算法介绍
    1. 首先，用 Str1 的第一个字符和 Str2 的第一个字符去比较，不符合，关键词向后移动一位  
    ![KMP图解01](/assets/01.java提升计划/01.数据结构与算法/04/KMP图解01.jpg)
    2. 一直重复，直到Str1 有一个字符与Str2 的第一个字符符合为止  
    ![KMP图解02](/assets/01.java提升计划/01.数据结构与算法/04/KMP图解02.jpg)
    3. 接着比较字符串和搜索词的下一个字符，还是符合。    
    ![KMP图解03](/assets/01.java提升计划/01.数据结构与算法/04/KMP图解03.jpg)
    4. 遇到Str1 有一个字符与Str2 对应的字符不符合    
    ![KMP图解04](/assets/01.java提升计划/01.数据结构与算法/04/KMP图解04.jpg)
    5. 这时候，想到的是继续遍历 Str1 的下一个字符，重复第 1 步。 (其实是很不明智的， 因为此时 BCD已经比较过了，没有必要再做重复的工作，一个基本事实是，当空格与 D不匹配时，你其实知道前面六个字符是"ABCDAB"。KMP 算法的想法是，设法利用这个已知信息，不要把"搜索位置"移回已经比较过的位置，继续把它向后移，这样就提高了效率。)    
    ![KMP图解05](/assets/01.java提升计划/01.数据结构与算法/04/KMP图解05.jpg)
    6. 怎么做到把刚刚重复的步骤省略掉？ 可以对 Str2计算出一张《部分匹配表》 ，这张表的产生在后面介绍  
    ![KMP图解06](/assets/01.java提升计划/01.数据结构与算法/04/KMP图解06.jpg)
    7. 已知空格与 D 不匹配时，前面六个字符"ABCDAB"是匹配的。查表可知，最后一个匹配字符"B"对应的"部分匹配值"为2，因此按照下面的公式算出向后移动的位数：  
        1. 移动位数 = 已匹配的字符数 - 对应的部分匹配值
        2. 因为 6 - 2 等于 4， 所以将搜索词向后移动 4 位。    
    8. 因为空格与"Ｃ"不匹配，搜索词还要继续往后移。这时，已匹配的字符数为 2（"AB"），对应的"部分匹配值"为0。所以，移动位数=2-0，结果为2，于是将搜索词向后移2位。  
    ![KMP图解07](/assets/01.java提升计划/01.数据结构与算法/04/KMP图解07.jpg)
    9. 因为空格与 A 不匹配，继续后移一位。  
    ![KMP图解08](/assets/01.java提升计划/01.数据结构与算法/04/KMP图解08.jpg) 
    10. 逐位比较，直到发现 C 与 D 不匹配。于是，移动位数 = 6 - 2， 继续将搜索词向后移动 4 位。  
    ![KMP图解09](/assets/01.java提升计划/01.数据结构与算法/04/KMP图解09.jpg) 
    11. 逐位比较，直到搜索词的最后一位，发现完全匹配，于是搜索完成。如果还要继续搜索（即找出全部匹配）,移动位数 = 7 - 0，再将搜索词向后移动 7 位，这里就不再重复了。    
    ![KMP图解10](/assets/01.java提升计划/01.数据结构与算法/04/KMP图解10.jpg) 
    12. 介绍《部分匹配表》 怎么产生的  
    ![KMP图解11](/assets/01.java提升计划/01.数据结构与算法/04/KMP图解11.jpg)  
        1. "部分匹配值"就是"前缀"和"后缀"的最长的共有元素的长度。以"ABCDABD"为例，
        2. "A" 的前缀和后缀都为空集， 共有元素的长度为 0；
        3. "AB" 的前缀为[A]， 后缀为[B]， 共有元素的长度为 0；
        4. "ABC" 的前缀为[A, AB]， 后缀为[BC,C]，共有元素的长度 0；
        5. "ABCD" 的前缀为[A, AB, ABC]，后缀为[BCD, CD, D]，共有元素的长度为 0；
        6. "ABCDA" 的前缀为[A, AB, ABC, ABCD]，后缀为[BCDA, CDA, DA, A]，共有元素为"A" ， 长度为 1；
        7. "ABCDAB"的前缀为[A, AB, ABC, ABCD, ABCDA]，后缀为[BCDAB, CDAB, DAB, AB, B]，共有元素为"AB"，长度为 2；
        8. "ABCDABD" 的前缀为[A, AB, ABC, ABCD, ABCDA, ABCDAB]，后缀为[BCDABD, CDABD, DABD, ABD, BD,D]，共有元素的长度为0。
    13. "部分匹配"的实质是，有时候，字符串头部和尾部会有重复。比如，"ABCDAB"之中有两个"AB" ，那么它的"部分匹配值" 就是2（"AB"的长度）。搜索词移动的时候，第一个"AB"向后移动 4 位（字符串长度部分匹配值），就可以来到第二个"AB" 的位置。

## 5.贪心算法
1. 贪心算法介绍
    1. 贪婪算法(贪心算法)是指在对问题进行求解时，在每一步选择中都采取最好或者最优(即最有利)的选择，从而希望能够导致结果是最好或者最优的算法
    2. 贪婪算法所得到的结果不一定是最优的结果(有时候会是最优解)，但是都是相对近似(接近)最优解的结果
2. 贪心算法最佳应用-集合覆盖
    1. 假设存在如下表的需要付费的广播台，以及广播台信号可以覆盖的地区。如何选择最少的广播台，让所有的地区都可以接收到信号  
    ![贪心例题](/assets/01.java提升计划/01.数据结构与算法/04/贪心例题.jpg)
    2. 遍历所有的广播电台, 找到一个覆盖了最多未覆盖的地区的电台(此电台可能包含一些已覆盖的地区，但没有关系）
    3. 将这个电台加入到一个集合中(比如 ArrayList), 想办法把该电台覆盖的地区在下次比较时去掉。
    4. 重复第 2 步直到覆盖了全部的地区
3. 贪心算法注意事项和细节
    1. 贪婪算法所得到的结果不一定是最优的结果(有时候会是最优解)，但是都是相对近似(接近)最优解的结果
    2. 比如上题的算法选出的是 K1, K2, K3, K5，符合覆盖了全部的地区
    3. 但是我们发现 K2, K3,K4,K5 也可以覆盖全部地区， 如果 K2 的使用成本低于 K1,那么我们上题的 K1, K2, K3,K5虽然是满足条件，但是并不是最优的

## 6.普里姆算法
1. 应用场景-修路问题  
![普里姆算法例题](/assets/01.java提升计划/01.数据结构与算法/04/普里姆算法例题.jpg)  
2. 修路问题本质就是就是最小生成树问题，先介绍一下最小生成树(Minimum Cost Spanning Tree)，简称 MST。给定一个带权的无向连通图,如何选取一棵生成树,使树上所有边上权的总和为最小,这叫最小生成树
    1. N 个顶点，一定有 N-1 条边
    2. 包含全部顶点
    3. N-1 条边都在图中
    4. 举例说明(如图:)
    5. 求最小生成树的算法主要是普里姆算法和克鲁斯卡尔算法  
    ![最小生成树](/assets/01.java提升计划/01.数据结构与算法/04/最小生成树.jpg)
3. 普里姆算法介绍
普利姆(Prim)算法求最小生成树，也就是在包含 n 个顶点的连通图中，找出只有(n-1)条边包含所有 n 个顶点的连通子图， 也就是所谓的极小连通子图普利姆的算法如下:   
![普里姆算法](/assets/01.java提升计划/01.数据结构与算法/04/普里姆算法.jpg)

## 7.克鲁斯卡尔算法
1. 应用场景-公交站问题  
![公交站问题](/assets/01.java提升计划/01.数据结构与算法/04/公交站问题.jpg)  
2. 克鲁斯卡尔算法介绍
    1. 克鲁斯卡尔(Kruskal)算法，是用来求加权连通图的最小生成树的算法。
    2. 基本思想： 按照权值从小到大的顺序选择 n-1 条边，并保证这 n-1 条边不构成回路
    3. 具体做法： 首先构造一个只含 n 个顶点的森林，然后依权值从小到大从连通网中选择边加入到森林中， 并使森林中不产生回路，直至森林变成一棵树为止
3. 克鲁斯卡尔算法图解说明  
![公交站](/assets/01.java提升计划/01.数据结构与算法/04/公交站.jpg)
例如，对于如上图 G4 所示的连通网可以有多棵权值总和不相同的生成树。   
![公交站问题图解](/assets/01.java提升计划/01.数据结构与算法/04/公交站问题图解.jpg)  
    1. 将边<E,F>加入 R 中。边<E,F>的权值最小， 因此将它加入到最小生成树结果 R 中。
    2. 将边<C,D>加入 R 中。上一步操作之后，边<C,D>的权值最小，因此将它加入到最小生成树结果 R 中。
    3. 将边<D,E>加入 R 中。上一步操作之后，边<D,E>的权值最小， 因此将它加入到最小生成树结果 R 中。
    4. 将边<B,F>加入 R 中。上一步操作之后，边<C,E>的权值最小，但<C,E>会和已有的边构成回路；因此，跳过边<C,E>。同理，跳过边<C,F>。 将边<B,F>加入到最小生成树结果 R 中。
    5. 将边<E,G>加入 R 中。上一步操作之后，边<E,G>的权值最小，因此将它加入到最小生成树结果 R 中。
    6. 将边<A,B>加入 R 中。上一步操作之后，边<F,G>的权值最小，但<F,G>会和已有的边构成回路；因此，跳过边<F,G>。 同理，跳过边<B,C>。 将边<A,B>加入到最小生成树结果 R 中。
    7. 此时，最小生成树构造完成！它包括的边依次是：<E,F> <C,D> <D,E> <B,F> <E,G> <A,B>。
4. 克鲁斯卡尔算法分析
    1. 问题一 : 对图的所有边按照权值大小进行排序。
    2. 问题二 : 将边添加到最小生成树中时，怎么样判断是否形成了回路。
    3. 问题一很好解决，采用排序算法进行排序即可。
    4. 问题二处理方式是： 记录顶点在"最小生成树"中的终点，顶点的终点是"在最小生成树中与它连通的最大顶点"。然后每次需要将一条边添加到最小生存树时，判断该边的两个顶点的终点是否重合，重合的话则会构成回路。
5. 如何判断是否构成回路-举例说明(如图)  
![如何判断是否构成回路](/assets/01.java提升计划/01.数据结构与算法/04/如何判断是否构成回路.jpg)  
在将<E,F>,<C,D>,<D,E>加入到最小生成树R中之后，这几条边的顶点就都有了终点：  
    1. C 的终点是 F,D 的终点是 F,E 的终点是 F,F 的终点是 F。
    2. 就是将所有顶点按照从小到大的顺序排列好之后；某个顶点的终点就是"与它连通的最大顶点"。
    3. 因此，接下来，虽然<C,E>是权值最小的边。但是 C 和 E 的终点都是F，即它们的终点相同，因此，将<C,E>加入最小生成树的话， 会形成回路。 这就是判断回路的方式。也就是说，我们加入的边的两个顶点不能都指向同一个终点， 否则将构成回路。 

## 8.迪杰斯特拉(Dijkstra)算法
1. 应用场景-最短路径问题  
![迪杰斯特拉算法](/assets/01.java提升计划/01.数据结构与算法/04/迪杰斯特拉算法.jpg)   
2. 迪杰斯特拉(Dijkstra)算法介绍
迪杰斯特拉(Dijkstra)算法是典型最短路径算法，用于计算一个结点到其他结点的最短路径。它的主要特点是以起始点为中心向外层层扩展(广度优先搜索思想)，直到扩展到终点为止。
3. 迪杰斯特拉(Dijkstra)算法过程
    1. 设置出发顶点为 v，顶点集合 V{v1,v2,vi...}，v 到 V中各顶点的距离构成距离集合 Dis，Dis{d1,d2,di...}，Dis集合记录着 v 到图中各顶点的距离(到自身可以看作 0， v 到 vi 距离对应为 di)
    2. 从 Dis 中选择值最小的 di 并移出 Dis 集合，同时移出 V 集合中对应的顶点 vi，此时的 v 到 vi 即为最短路径
    3. 更新 Dis 集合，更新规则为： 比较 v 到 V 集合中顶点的距离值， 与 v 通过 vi 到 V 集合中顶点的距离值，保留值较小的一个(同时也应该更新顶点的前驱节点为 vi，表明是通过 vi 到达的)
    4. 重复执行两步骤，直到最短路径顶点为目标顶点即可结束

## 9.弗洛伊德算法
1. 弗洛伊德(Floyd)算法介绍
    1. 弗洛伊德算法(Floyd)计算图中各个顶点之间的最短路径
    2. 迪杰斯特拉算法用于计算图中某一个顶点到其他顶点的最短路径。
    3. 弗洛伊德算法 VS 迪杰斯特拉算法： 
        1. 迪杰斯特拉算法通过选定的被访问顶点，求出从出发访问顶点到其他顶点的最短路径； 
        2. 弗洛伊德算法中每一个顶点都是出发访问点，所以需要将每一个顶点看做被访问顶点，求出从每一个顶点到其他顶点的最短路径。
2. 弗洛伊德(Floyd)算法图解分析
    1. 设置顶点 vi 到顶点 vk 的最短路径已知为 Lik， 顶点 vk 到 vj 的最短路径已知为 Lkj，顶点 vi 到 vj 的路径为 Lij，则 vi 到 vj 的最短路径为： min((Lik+Lkj),Lij)，vk 的取值为图中所有顶点， 则可获得 vi 到 vj 的最短路径
    2. 至于 vi 到 vk 的最短路径 Lik 或者 vk 到 vj 的最短路径 Lkj， 是以同样的方式获得
3. [弗洛伊德算法讲解链接](https://www.bilibili.com/video/BV1E4411H73v?p=185)

## 10.马踏棋盘算法
1. 马踏棋盘算法介绍和游戏演示
    1. 马踏棋盘算法也被称为骑士周游问题
    2. 将马随机放在国际象棋的 8×8 棋盘 Board\[0～7\]\[0～7\]的某个方格中，马按走棋规则(马走日字)进行移动。 要求每个方格只进入一次，走遍棋盘上全部 64 个方格  
    ![马踏棋盘算法](/assets/01.java提升计划/01.数据结构与算法/04/马踏棋盘算法.jpg)  
2. 马踏棋盘游戏思路  
![马踏棋盘算法思路](/assets/01.java提升计划/01.数据结构与算法/04/马踏棋盘算法思路.jpg)  
3. 贪心优化 : 每走一步对接下来可走的点位按再下一步可走的步数进行排序
