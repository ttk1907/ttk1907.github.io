---
layout: post
title:  "自定义持久层框架"
date:   2021-05-16
categories: lagou
tags: lagou
---

* content
{:toc}


1. 第一阶段、开源框架源码解析
2. 模块一、持久层框架设计及MyBatis源码分析
    1. 任务一、自定义持久层框架
    2. 任务二：MyBatis基础回顾及高级应用
    3. 任务三：MyBatis源码剖析
    4. 任务四：模块作业
    5. 直播答疑





 
# 任务1、自定义持久层框架
## 1.1 分析JDBC操作问题  
```java
public static void main(String[] args) {
        Connection connection = null;
        PreparedStatement preparedStatement = null;
        ResultSet resultSet = null;
        try {
            // 加载数据库驱动
            Class.forName("com.mysql.jdbc.Driver");
            // 通过驱动管理类获取数据库链接
            connection = DriverManager.getConnection("jdbc:mysql://localhost:3306/mybatis?characterEncoding=utf-8", "root", "root");
            // 定义sql语句？表示占位符
            String sql = "select * from user where username = ?";
            // 获取预处理statement
            preparedStatement = connection.prepareStatement(sql);
            // 设置参数，第一个参数为sql语句中参数的序号(从1开始)，第二个参数为设置的参数值
            preparedStatement.setString(1, "tom");
            // 向数据库发出sql执行查询，查询出结果集
            resultSet = preparedStatement.executeQuery();
            // 遍历查询结果集
            while (resultSet.next()) {
                int id = resultSet.getInt("id");
                String username = resultSet.getString("username");
                // 封装User
                user.setId(id);
                user.setUsername(username);
            }
            System.out.println(user);
        } catch (
                Exception e) {
            e.printStackTrace();
        } finally {
            // 释放资源
            if (resultSet != null) {
                try {
                    resultSet.close();
                } catch (SQLException e) {
                    e.printStackTrace();
                }
            }
            if (preparedStatement != null) {
                try {
                    preparedStatement.close();
                } catch (SQLException e) {
                    e.printStackTrace();
                }
            }
        }
}
```  

**JDBC问题总结：**
原始jdbc开发存在的问题如下：
1. 数据库连接创建、释放频繁造成系统资源浪费，从而影响系统性能。
2. Sql语句在代码中硬编码，造成代码不易维护，实际应用中sql变化的可能较大，sql变动需要改变java代码。
3. 使用preparedStatement向占有位符号传参数存在硬编码，因为sql语句的where条件不一定，可能多也可能少，修改sql还要修改代码，系统不易维护。
4. 对结果集解析存在硬编码(查询列名)，sql变化导致解析代码变化，系统不易维护，如果能将数据 库记录封装成pojo对象解析比较方便

## 1.2 问题解决思路
1. 使用数据库连接池初始化连接资源
2. 将sql语句抽取到xml配置文件中
3. 使用反射、内省等底层技术，自动将实体与表进行属性与字段的自动映射

## 1.3 自定义框架设计

**使用端：**
>提供核心配置文件：
>sqlMapConfig.xml : 存放数据源信息，引入mapper.xml
>Mapper.xml : sql语句的配置文件信息

**框架端：**
1. 读取配置文件

>读取完成以后以流的形式存在，我们不能将读取到的配置信息以流的形式存放在内存中，不好操作，可以创建javaBean来存储
>1. `Configuration` : 存放数据库基本信息、Map<唯一标识，Mapper> 唯一标识：namespace + "." +id
>2. `MappedStatement` : sql语句、statement类型、输入参数java类型、输出参数java类型

2. 解析配置文件

>创建sqlSessionFactoryBuilder类：
>方法：sqlSessionFactory build()：
>1. 使用dom4j解析配置文件，将解析出来的内容封装到Configuration和MappedStatement中
>2. 创建SqlSessionFactory的实现类DefaultSqlSession

3. 创建SqlSessionFactory：

>方法：openSession() : 获取sqlSession接口的实现类实例对象

4. 创建sqlSession接口及实现类：主要封装crud方法

>方法：selectList(String statementId,Object param)：查询所有
>方法：selectOne(String statementId,Object param)：查询单个
>具体实现：封装JDBC完成对数据库表的查询操作

5. 涉及到的设计模式：Builder构建者设计模式、工厂模式、代理模式

## 1.4 自定义框架设计
在使用端项目中创建配置配置文件
创建 sqlMapConfig.xml
```xml
<code> 
<configuration>
    <!--数据库连接信息-->
    <property name="driverClass" value="com.mysql.jdbc.Driver"></property>
    <property name="jdbcUrl" value="jdbc:mysql:///zdy_mybatis"></property>
    <property name="user" value="root"></property>
    <property name="password" value="root"></property>
    <!--引入sql配置信息--> -->
    <mapper resource="mapper.xml"></mapper>
</configuration>
</code> 
```





